# Reference this view as marts__fct_campaign_influence
label: Marketing Pipeline Semantic

schema: MARTS
table_name: FCT_CAMPAIGN_INFLUENCE

dimensions:
  opportunity_id:
    sql: '"OPPORTUNITY_ID"'
    format: ID

  id:
    sql: '"ID"'
    format: ID
    primary_key: true

  opportunity_created_date:
    sql: '"OPPORTUNITY_CREATED_DATE"'

  campaign_member_created_date:
    sql: '"CAMPAIGN_MEMBER_CREATED_DATE"'

  opportunity_amount:
    sql: '"OPPORTUNITY_AMOUNT"'

  opportunity_type:
    sql: '"OPPORTUNITY_TYPE"'

  campaign_name:
    sql: '"CAMPAIGN_NAME"'

  campaign_type:
    sql: '"CAMPAIGN_TYPE"'

  account_name:
    sql: '"ACCOUNT_NAME"'

  account_type:
    sql: '"ACCOUNT_TYPE"'

  account_tier:
    sql: '"ACCOUNT_TIER"'

  attendee_status:
    sql: '"ATTENDEE_STATUS"'

  attendee_type:
    sql: '"ATTENDEE_TYPE"'

  is_created_after_campaign_touch:
    sql: '"IS_CREATED_AFTER_CAMPAIGN_TOUCH"'

  _entity_opportunity:
    # Entity is defined in the 'marketing_pipeline_semantic' dbt semantic model (models/semantic_models/sem_campaign.yml)
    sql: ${opportunity_id}
    hidden: true

measures:
  count:
    aggregate_type: count

#The info below was pulled from your dbt repository and is read-only.
dbt:
  name: fct_campaign_influence
  target_schema: STAGING
  config:
    schema: marts
    materialized: table
  code: |-
    -- This is a simplified example. Your logic may need to be more complex.
    -- You might use a dbt package like salesforce_source for staging models.

    with opps as (
        select * from {{ ref('stg_salesforce__opportunity') }}
    ),

    accounts as (
        select * from {{ ref('stg_salesforce__accounts') }}
    ),

    contacts as (
        select * from {{ ref('stg_salesforce__contacts') }}
    ),

    campaign_members as (
        select * from {{ ref('stg_salesforce__campaign_member') }}
    ),

    campaigns as (
        select * from {{ ref('stg_salesforce__campaign') }}
    )

    select
        -- IDs
        opps.opportunity_id,
        campaign_members.id,

        -- Timestamps
        opps.opportunity_created_date as opportunity_created_date,
        campaign_members.created_date as campaign_member_created_date,

        -- Amounts
        opps.amount as opportunity_amount,

        -- Key Dimensions and Flags
        opps.opportunity_type as opportunity_type, -- e.g., 'New Business', 'Existing Business'
        campaigns.name as campaign_name,
        campaigns.type as campaign_type, -- e.g., 'In-Person Event', 'Virtual Event'
        accounts.account_name as account_name,
        accounts.account_type as account_type, -- e.g., 'Prospect', 'Customer'
        accounts.account_tier as account_tier, -- Custom field for account segmentation
        campaign_members.status as attendee_status, -- e.g., 'Attended', 'No Show'
        contacts.title as attendee_type, -- e.g., 'Manager', 'VP', 'C-Level'

        -- Crucial Flag for New vs. Progressed Pipeline
        (opps.opportunity_created_date > campaign_members.created_date) as is_created_after_campaign_touch

    from opps
    -- Join opps to accounts
    left join accounts on opps.account_id = accounts.account_id
    -- Find the contacts associated with that opportunity's account
    left join contacts on accounts.account_id = contacts.account_id
    -- Find all campaign memberships for those contacts
    left join campaign_members on contacts.contact_id = campaign_members.contact_id
    -- Get campaign details
    left join campaigns on campaign_members.campaign_id = campaigns.id

    -- You need a filter here to define your attribution window,
    -- for example, only associating opps created within 90 days of a campaign touch.
    where {{ dbt.datediff('campaign_members.created_date', 'opps.opportunity_created_date', 'day') }} between 0 and 90
